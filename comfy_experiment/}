#![allow(clippy::wildcard_imports)]
use comfy::{image::GenericImageView, *};
use serde::Deserialize;
use std::str;

// load JSON slice
// {"slices":17,"frames":1,"width":45,"height":34}
#[derive(Debug, Deserialize)]
pub struct SlicesConf {
    slices: u32,
    frames: u32,
    width: u32,
    height: u32,
}

// Game config
pub struct GameState {
    pub data: (f32, f32, Vec2),
    pub slices: SlicesConf,
}

impl GameState {
    pub fn new(_c: &mut EngineContext) -> Self {
        Self {
            data: (0.0, 0.0, splat(0.0)),
            slices: SlicesConf {
                slices: 0,
                frames: 0,
                width: 0,
                height: 0,
            },
        }
    }

    pub fn update_values(&mut self) {
        let screen_width_pixels = screen_width(); // for example: 1800
        let screen_height_pixels = screen_height(); // for example: 920
        let visible_world_size = main_camera().world_viewport(); // for example: 30.0 x 16.8

        if screen_width_pixels != self.data.0 || screen_height_pixels != self.data.1 {
            self.data.0 = screen_width_pixels;
            self.data.1 = screen_height_pixels;
            self.data.2 = visible_world_size;
            println!("screen_width_pixels: {screen_width_pixels}");
            println!("screen_height_pixels: {screen_height_pixels}");
            println!("visible_world_size: {visible_world_size}");
        }
    }
}

pub struct GameContext<'a, 'b: 'a> {
    pub game_state: &'a mut GameState,
    pub engine: &'a mut EngineContext<'b>,
}

fn make_context<'a, 'b: 'a>(
    state: &'a mut GameState,
    engine: &'a mut EngineContext<'b>,
) -> GameContext<'a, 'b> {
    GameContext {
        game_state: state,
        engine,
    }
}

comfy_game!(
    "This is a test",
    GameContext,
    GameState,
    make_context,
    setup,
    update
);

fn setup(c: &mut GameContext) {
    c.engine
        .load_texture_from_bytes("car", include_bytes!("../asssets/slices.png"));
    c.game_state.slices = serde_json::from_str(
        str::from_utf8(include_bytes!("../asssets/slices.json"))
            .expect("Unable to read JSON bytes"),
    )
    .expect("Unable to parse JSON");

    let mut camera = main_camera_mut();
    camera.zoom = 20.0;

    println!("Slices: {:?}", c.game_state.slices);
}

fn update(c: &mut GameContext) {
    clear_background(WHITE);

    c.game_state.update_values();

    let height = c.game_state.slices.height as f32;
    let width = c.game_state.slices.width as f32;

    let dest_size = Size::world(1.0, height / width);

    let t = get_time() as f32;

    for i in 0..c.game_state.slices.slices {
        let height = c.game_state.slices.height as i32;
        let width = c.game_state.slices.width as i32;
        let src_rect = IRect::new(ivec2(0, i as i32 * height), ivec2(width, height));
        draw_sprite_ex(
            texture_id("car"),
            vec2(0.0, 0.02 * i as f32),
            GRAY,
            i as i32,
            DrawTextureParams {
                dest_size: Some(dest_size),
                source_rect: Some(src_rect),
                rotation: t,
                ..Default::default()
            },
        );
    }
}
